// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String         @id @default(cuid())
  firstName       String?
  lastName        String?
  email           String?        @unique
  emailVerified   DateTime?
  image           String?
  password        String?
  isAdmin         Boolean        @default(false)
  status          UserStatus     @default(ACTIVE)
  subscription    Subscription?
  accounts        Account[]
  sessions        Session[]
  apiKeys         ApiKey[]       // Add this relation
  groqKeySessions GroqKeySession[]
  usageRecords    Usage[]
  monthlyUsage    Int            @default(0)
  totalUsage      Int            @default(0)
  activities      UserActivity[]
  adminAuditLogs  AdminAuditLog[]  @relation("AdminAuditLogs")
  targetAuditLogs AdminAuditLog[]  @relation("TargetAuditLogs")
  tokenUsages     TokenUsage[]
  payments        Payment[]
  lastActive      DateTime?
  recentActivity  Json[]         @default([])
  stripeCustomerId String?
  groqKeyUsages   GroqKeyUsage[] 
  resetToken       String?       @unique
  resetTokenExpiry DateTime?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@index([email])
  @@index([createdAt])
}

model Subscription {
  id               String           @id @default(cuid())
  user             User             @relation(fields: [userId], references: [id])
  userId           String           @unique
  stripeId         String?
  tier             SubscriptionTier @default(FREE)
  monthlyLimit     Int              @default(10000)
  availableTokens  Int              @default(0)
  tokenLimit       Int              @default(100000)
  status           String           @default("ACTIVE")
  currentPeriodEnd DateTime?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
}

model Usage {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  type      String
  amount    Int      @default(0)
  tokens    Int      @default(0)
  cost      Float
  createdAt DateTime @default(now())

  @@index([userId])
}

model ApiKey {
  id          String    @id @default(cuid())
  key         String    @unique
  user        User?     @relation(fields: [userId], references: [id])
  userId      String?
  isActive    Boolean   @default(true)
  totalUsage  Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  status String @default("available")
  totalTokensUsed Int @default(0)
  lastUsed DateTime?

  @@index([userId])
  @@index([createdAt])
}

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?  @db.Text
  access_token       String?  @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?  @db.Text
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model GroqKey {
  id             String         @id @default(cuid())
  key            String         @unique
  isInUse        Boolean        @default(false)
  currentSession GroqKeySession? @relation("CurrentSession", fields: [currentSessionId], references: [id])
  currentSessionId String?      @unique
  lastUsed       DateTime?
  totalRequests  Int           @default(0)  
  totalTokens    BigInt        @default(0)  
  totalCost      Decimal       @db.Decimal(10,4) @default(0)  
  errorCount     Int           @default(0)
  totalUsage     Int           @default(0)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  sessions       GroqKeySession[]
  usageHistory   RequestLog[]  
  keyUsages      GroqKeyUsage[]

  @@index([createdAt])
}

model GroqKeySession {
  id          String    @id @default(cuid())
  groqKey     GroqKey   @relation(fields: [groqKeyId], references: [id])
  groqKeyId   String
  user        User      @relation(fields: [userId], references: [id])
  userId      String
  startedAt   DateTime  @default(now())
  endedAt     DateTime?
  tokensUsed  Int       @default(0)
  currentKey  GroqKey?  @relation("CurrentSession")

  @@index([groqKeyId])
  @@index([userId])
  @@index([startedAt])
}

model UserActivity {
  id           String    @id @default(cuid())
  user         User      @relation(fields: [userId], references: [id])
  userId       String
  activityType String
  details      Json?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([userId])
  @@index([createdAt])
}

model AdminAuditLog {
  id             String    @id @default(cuid())
  admin          User      @relation("AdminAuditLogs", fields: [adminId], references: [id])
  adminId        String
  actionType     String
  details        Json?
  targetUser     User?     @relation("TargetAuditLogs", fields: [targetUserId], references: [id])
  targetUserId   String?
  targetResource String?
  createdAt      DateTime  @default(now())

  @@index([adminId])
  @@index([targetUserId])
  @@index([createdAt])
}

model TokenUsage {
  id          String   @id @default(cuid())
  user        User     @relation(fields: [userId], references: [id])
  userId      String
  tokensUsed  Int
  requestType String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([createdAt])
}

model Payment {
  id            String   @id @default(cuid())
  user          User     @relation(fields: [userId], references: [id])
  userId        String
  amount        Int
  currency      String   @default("usd")
  status        String
  stripePaymentId String?
  type          String   // subscription, overage, etc.
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([userId])
  @@index([createdAt])
  @@index([status])
}

model RequestLog {
  id          String    @id @default(cuid())
  keyId       String
  timestamp   DateTime  @default(now())
  latency     Int
  tokens      Int
  cost        Decimal   @db.Decimal(10,4)
  success     Boolean
  errorType   String?
  userId      String?
  requestType String
  key         GroqKey   @relation(fields: [keyId], references: [key], onDelete: Cascade)

  @@index([keyId])
  @@index([timestamp])
}

model GroqKeyUsage {
  id           String    @id @default(cuid())
  groqKey      GroqKey   @relation(fields: [groqKeyId], references: [id])
  groqKeyId    String
  requestType  String
  tokensUsed   Int
  userId       String?  
  user         User?     @relation(fields: [userId], references: [id]) 
  cost         Float     @default(0) 
  responseTime Int       @default(0) 
  success      Boolean   @default(true) 
  error        String?  
  createdAt    DateTime  @default(now())

  @@index([groqKeyId])
  @@index([createdAt])
  @@index([userId])
}

model RateLimit {
  id            String   @id @default(cuid())
  userId        String
  type          String   // "minute", "hour", "day", "month"
  count         Int      @default(0)
  expiresAt     DateTime
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([userId, type])
  @@index([userId])
  @@index([expiresAt])
}

model TokenBalance {
  id            String   @id @default(cuid())
  userId        String   @unique
  baseTokens    Int      // Monthly allocation based on tier
  extraTokens   Int      // Additional purchased or admin-granted tokens
  updatedAt     DateTime @updatedAt

  @@index([userId])
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  PENDING_VERIFICATION
}

enum SubscriptionTier {
  FREE
  BASIC
  PREMIUM
  ENTERPRISE
}